==Введение==
---------
Написание программы, это далеко не простой и не быстрый процесс. И дело здесь не только в количестве кода программы и времени на его написание. Кодирование (а именно так называется то, что многие называют программированием), не самая важная часть в написании программного обеспечения. Программист (а именно так называют себя многие кодеры), это не только тот человек, который пишет код программы. С таким же успехом можно посадить женщину-наборщицу и дать ей код программы, чтобы она печатала. Так что, теперь её можно называть программисткой? Вовсе нет.<br/>
В дальнейшем, я постараюсь расширить кругозор большинства программистов (вернее кодеров), и натолкнуть их действительно на разработку программ, а не на их кодирование. В результате вы сможете разрабатывать (не писать, а именно разрабатывать) более качественный софт, и затрачивать меньше времени на кодирование. Кроме того программирование будет доставлять больше удовольствия! Лично мне гораздо приятнее писать программы, чем играть в какие-то игры.<br/>
Итак, приступим.<br/>
Весь процесс разработки ПО можно разделить на вот такие этапы:<br/>
1. Анализ.<br/>
2. Проектирование.<br/>
3. Кодирование.<br/>
4. Отладка / Тестирование.<br/>
5. Развёртывание / Сопровождение.<br/>
<br/>
Кратенько о каждом из них.<br/>
 Анализ. Прежде чем что-либо писать, нужно придумать, что мы будем писать, кому мы будем писать, зачем мы будем писать и так далее. Нужно проанализировать, а будет ли спрос на это ПО, будут ли им пользоваться, и не закидают ли нас помидорами?<br/>
 Проектирование. Здесь нам нужно будет продумать, как мы будем писать программу? Выделить основные элементы, найти наиболее подходящий интерфейс взаимодействия с пользователем, в общем, продумать всё до мелочей. От того, как хорошо мы проектируем наше ПО, зависит его качество, затраченные нервы и время на кодирование.<br/>
 Кодирование. Имея на руках план разработки, мы можем смело приступать к кодированию. Тут тоже есть много подводных камней, наткнувшись на которые, даже хорошо спроектированный проект, может сильно пошатнуться.<br/>
 Отладка и тестирование. Тестирование отличается от отладки тем, что тестировать должен не разработчик (это называется отладкой), а другие люди - тестеры, пользователи, заказчик, баба Мотря. Это наиболее зависимая часть. От того, как программист относился к первым трём частям разработки, зависит время и успешность тестирования. На этом этапе ПО отдаётся ограниченной группе пользователей или тестировщикам, после чего они выносят свой вердикт, что нравится, а что не нравится в вашей программе.<br/>
 Развёртывание - это то, как будет вести себя программа, когда пользователь начнёт её установку. Будет ли она работать на конкретном аппарате или вообще не запустится? Сопровождение. После успешного тестирования мы можем смело распространять наше приложение - либо выкладывать в интернет, либо отдавать заказчику. Потребуется некоторая помощь в использовании программы, например предоставление документации, или простое руководство пользователя. Всё это и называется сопровождением.<br/>
<br/>
==1. Анализ.==<br/>
<br/>
Как я уже и говорил, прежде чем что-либо писать, нужно проанализировать, а нужно ли вообще писать?<br/>
Для начала нужна идея. Хорошая идея - залог успеха. Где её искать? Ну, во-первых, можно придумать. Но как показывает практика, что-либо придумать самому довольно трудно. Чаще всего идеи приходят в самый неожиданный момент - при прыжке с парашютом, на экзамене, в маршрутке, в армии, в ванной. Запомнить идею в таких ситуациях сложно. Как вариант, можно записать её на листок. Но вот где взять листок, если ты летишь по воздуху с парашютом? Да и согласитесь, сдать экзаменационный билет с надписью "Написать электронную шпаргалку по английскому", не очень хорошо. <br/>
Поэтому можно еще полазить по форумам, в поиске хороших идей. Ищите подобные темы: "Идеи для новых программ", "Напишите программу", "Здесь есть программисты?" и тому подобные. На крайний случай можно самому создать такую тему.<br/>
Как правило, в этих темах люди чаще всего требуют невозможного, но вот слепить из их просьб что-то уникальное вполне реально.<br/>
Также есть еще один вариант, составить конкуренцию одной из популярных программ. Но здесь вы должны быть уверены, что вы сможете это сделать. Просто так сесть и написать программу-конкурента фотошопу у вас врядли получится, нужно жестко оценивать свои силы и силы конкурентов.<br/>
После того, как есть идея, нужно спросить, а зачем писать? Если первым делом в голову пришел ответ "Просто, от нечего делать", то ищите другую идею, так как эту программу вы не напишите. Даже если сейчас, сегодня, эту неделю, вы уверены, что программа нужна пользователям, это не значит, что у вас не возникнут сомнения потом, завтра, на следующую неделю. На вопрос "Зачем писать?" вы должны дать четкий и ясный ответ так, чтобы самому потом удивиться "Это я сказал???"!<br/>
Наконец нужно посмотреть, кому и куда писать. Электронная бухгалтерия врядли будет иметь спрос среди жителей Непала. Да и твикер реестра не понадобится пользователям мобильных телефонов. Это всё нужно учитывать.<br/>
Советую не приступать сразу после этого к следующим этапам разработки, подождите недельку, быть может, у вас появятся сомнения, или вы захотите написать программу на другую платформу или операционную систему. Также не кричите на всё тех же форумах во весь голос, мол, собираетесь реализовать ту или иную идею. Во-первых, что вы потом скажете, если забросите разработку, а люди будут ждать? Во-вторых, другой разработчик может запросто украсть у вас эту идею. И вы можете остаться ни с чем. Поэтому не распространяйтесь о том, что вы что-то задумали. Можете посоветоваться, но только с проверенными людьми. Но будьте начеку. Чем дороже идея, тем выше риск.<br/>
<br/>
[color FF0000]Вывод.[/color]<br/>
Прежде чем за что-то взяться, нужно понять, за что вы садитесь, дабы не терять времени на бессмысленные разработки.<br/>
<br/>
==2. Проектирование.==<br/>
<br/>
После того, как мы проанализировали кому, куда и зачем писать программу, приступайте к проектированию.<br/>
Выключите компьютер, возьмите лист бумаги и карандаш. Это как минимум. Идеальный вариант - отдать свой винчестер другу на неделю, чтобы не включать компьютер. Заодно отдать телевизор, телефон и вообще, лучше неделю пожить в пещере с карандашом и бумагой, так вы сможете лучше сконцентрироваться, и ничто вас не будет отвлекать. Ваша задача описать всю структуру приложения, все проблемы, которые могут возникнуть при разработке, разработать интерфейс.<br/>
Начните с простого - списка того, что программа должна выполнять. Сначала составьте список наиболее важных функций, затем второстепенных и, наконец, едва значимых. <br/>
Теперь начинайте разбивать каждую функцию на более мелкие части, затем эти мелкие части еще на более мелкие и так далее. Этот процесс называется декомпозицией. Делайте так до тех пор, пока разбить уже будет невозможно - всё и так ясно.<br/>
Дабы не быть голословным, приведу пример. Допустим, мы хотим написать просмотрщик графических файлов. Что в него может входить? Файловый менеджер (мы ведь будем открывать картинки из папок на диске), сам модуль просмотра, модуль плагинов (для добавления новых форматов графики), справка и так далее. Модуль просмотра можно разделить на обработчик файла (мы считываем файл и преобразовываем в набор пикселей), вывод тех самых пикселей на экран, применение каких-либо эффектов к картинке, масштабирование изображения и т.д. Обработчик файла можно разделить на считывание массива байт файла, сканирование этого массива в целях узнать формат изображения (PNG, JPG, BMP и т.д.), определение размера картинки (чтобы создать массив пикселей), заполнение массива пикселей обработанными данными массива байт файла. Определение формата изображения делится на сравнение первых байт (сигнатуры) файла с сигнатурой поддерживаемых нашей программой форматов. Очевидно, что дальше разбивать эту часть некуда, тут и так можно представить код наподобие этого: if(signatureFileBytes.equals(PNG_SIGNATURE)) {...}<br/>
После таких разбиений понимать программу станет легче, и процесс кодирования будет проходить проще и быстрее.<br/>
Советую напротив каждой из разбитых частей (у вас что-то типа дерева должно получиться) написать пару строк о том, что это за часть и какие её основные функции и проблемы.<br/>
Затем можно начинать рисовать интерфейс. Если у вас есть друзья дизайнеры, то поручите им эту работу, а сами продолжайте жить в пещере и совершенствовать свой список, добавляя новые функции и разбивая неразбитые части. Если друзей нет или большой злой медведь не выпускает вас из пещеры, то рисуйте интерфейс сами. Здесь нужно продумать каждый пункт меню, каждое место окна программы. Не должно быть ничего лишнего, доступ к функциям должен происходить за минимальное количество нажатий, всё должно быть просто и ясно, так, чтобы даже медведь разобрался в вашей программе и, наконец, выпустил бы вас из пещеры.<br/>
Когда следует выходить из пещеры, вы поймёте сами. Вам настолько станет всё ясно, что сдерживать себя от того, чтобы приступить к написанию, вы не сможете. Бегите к своему другу и забирайте свою аппаратуру. Вы готовы к кодированию.<br/>
<br/>
[color FF0000]Выводы.[/color]<br/>
Относитесь к проектированию очень серьёзно. Просто так написать хорошую программу нельзя, лучше продумать её структуру и всё по полочкам разложить, чем потом проектировать при программировании, что сильно отвлекает.<br/>
<br/>
<br/>
==3. Кодирование.==<br/>
<br/>
В процессе кодирования вы больше времени читаете код, нежели пишете. Поэтому скорость, качество и желание, зависит от того, как правильно вы будете писать и оформлять код. Конкретно по написанию кода что-либо говорить не имеет смысла, каждый это делает в силу своего интеллекта и изощренности. Обучать какому-то языку программирования я тоже здесь вас не стану. Но вот дать некоторые рекомендации по написанию и оформлению кода могу.<br/>
<br/>
<br/>
[color 008800]Комментарии.[/color]<br/>
Описывайте всё в комментариях, не скупитесь на них. Исходный код должен быть подобен рассказу, взглянув на который, человек, не смыслящий в языках программирования, должен сказать "Чёрт возьми, это крутой сценарий!". Объявили переменную - кратенько её описали, создали новую функцию или класс - опишите, что он делает. Это даст гарантию тому, что спустя некоторое время, вы, посмотрев на исходник, вспомните о чём шла речь и без труда сможете продолжить разработку.<br/>
<br/>
<br/>
[color 008800]Форматирование.[/color]<br/>
Представьте, что во всех книгах не было бы отступов и абзацев. Просто предложение за предложением, без пропуска строк, без серий пробелов. Вам было приятно читать такие книги? Не думаю. Так и в программировании. Не следует писать набор операторов в одну строку, вам сложнее будет потом всё это читать. Делайте отступы в каждом контейнере.<br/>
Например, этот код плохо читается:<br/>
<code java>for(int i=0;i<5;i++) {
if(idx==i){
g.setColor(0x0A6631);
}else{
g.setColor(0x0B2466);}
g.drawString(menu[i], 5, 30*i, 20);
}</code>
Этот лучше:<br/>
<code java>for (int i = 0; i < 5; i++) {
    if (idx == i) {
        g.setColor(0x0A6631);
    } else {
        g.setColor(0x0B2466);
    }
    g.drawString(menu[i], 5, 30 * i, 20);
}</code><br/>
А этот вообще классный:<br/>
<code java>//Вывод меню
for (int i = 0; i < MAX_MENU_ELEMENTS; i++) {
    if (currentMenuIndex == i) {
        //Выделенный пункт меню - один цвет
        g.setColor(Colors.HIGHLIGHT_MENU_TEXT);
    } else {
        //Не выделенный пункт меню - другой цвет
        g.setColor(Colors.MENU_TEXT);
    }
    //Вывод пункта меню на экран
    g.drawString(menuItems.getItem(i), MENU_X_COORDINATE, MENU_ELEMENT_HEIGHT * i, Graphics.TOP | Graphics.LEFT);
}</code><br/>
<br/>
<br/>
[color 008800]Имена.[/color]<br/>
Окажите себе услугу - объявляйте переменным, классам и всему тому, чему можно дать название, достойные имена. А разбираться в переменных ab, q, tt, вам самим же будет сложно. Вас же не зовут Rtt _aaa yy, вот и вы не называйте всё так. Допустим сегодня вы и понимаете, за что отвечают эти классы или переменные, но пройдёт время, и вы напрочь про всё забудете. Разбираться будет лень, и разработка наверняка прекратится, потому что удовольствия вы получать не будете.<br/>
Посмотрите на этот код:<br/>
<code java>class myclass {
int a;
int[] array;
float tmp;
boolean b;
}</code><br/>
Вы сможете сказать, о чём вообще идёт речь? Если да, то вы великий обманщик или прорицатель. Теперь посмотрите на это:<br/>
<code java>class Platform {
  int levelCount;
  int[] numOfPlatformsInLevel;
  float platformSpeed;
  boolean isPLatformActive;
}</code><br/>
Вы видите всего лишь четыре переменные и название класса, а уже можно сделать предположение, что это код из какой-то игры наподобие Arcanoid.<br/>
Имена классов следует называть с большой буквы, в то время как имена методов и переменных начинаются с маленькой буквы и каждое следующее слово начинается с большой буквы.<br/>
Пример неправильного названия переменных:<br/>
int numofplatformsinlevel;<br/>
getnewsize(picture pct) {}<br/>
Правильно так:<br/>
int numOfPlatformsInLevel;<br/>
getNewsize(Picture pct) {}<br/>
<br/>
<br/>
[color 008800]Константы.[/color]<br/>
Заменяйте повторяющиеся свободные значения в коде на константы. Сравните:<br/>
<code java>if(key == 54) {
  if(cursorX < 237)
    cursorX += 3;
}</code><br/>
и<br/>
<code java>if(key == KEY_NUM6) {
  if(cursorX < (SCREEN_WIDTH - CURSOR_STEP))
    cursorX += CURSOR_STEP;
}</code><br/>
Что даёт использование констант? Во-первых, становится понятнее, что это за значение. Во-вторых, если вдруг нужно будет поменять это значение, то это придётся сделать лишь один раз - при объявлении константы. Не придётся искать все значения и менять их на новые - это очень долго и мучительно.<br/>
Константы принято называть большими буквами, придерживайтесь этого правила.<br/>
<br/>
<br/>
[color 008800]Конструкторы.[/color]<br/>
Конструктор в объектно-ориентированном программировании - это некий кусок кода, похожий на метод, который инициализирует все данные в объекте при его вызове. То есть мы создали класс, инициализируем его, и тот код, который вызывается при инициализации класса и есть конструктор. В свою очередь конструктор инициализирует другие переменные, которые есть в этом классе. Многие, к сожалению, забывают про истинное назначение конструктора, и не часто ими пользуются. Потом выходят такие куски кода:<br/>
<code java>class MyClass {
String nc="",n1="";
int x=10,cls=0,xx;
MyClass() {}
}</code><br/>
Как минимум, такой код неэтичен. К тому же, такое беспорядочное написание больше подвержено ошибкам. Конструктор служит для инициализации переменных! Запомните это. Правильное использование конструктора таково:<br/>
<code java>class MyClass {

  int x, xx, cls;
  String nc, n1;
  
  MyClass() {
      x = 10;
      cls = 0;
      nc = "";
      n1 = "";
  }
}</code><br/>
В таком случае, вы всегда будете знать, где нужно искать код инициализации переменной. Ведь в первом случае, строки инициализации можно поместить и в конец класса и в середину. А как потом искать? Лучше уж сразу писать правильно. Единственное, что не нужно инициализировать в конструкторе - это константы. Для них как раз отведено место под строкой объявления класса.<br/>
<br/>
<br/>
[color 008800]Контейнеры.[/color]<br/>
Контейнеры - это объединённая в одну логическую структуру часть кода. Контейнеры в разных языках оформляются по-разному. В C++, Java и большинстве языках, они обрамляются в фигурные скобки { }. В языке Pascal в begin end. Отсутствие контейнера в некоторых управляющих конструкциях не обязательна, но существенно упрощает понимание кода, да и ошибок будет меньше. Взгляните на этот код:<br/>
<code java>for(int menuIndex = 0; menuIndex < MAX_MENU_ELEMENTS; menuIndex++)
  if(menuIndex == currentIndex)
    if(!menuEnabled[currentIndex])
      menuEnabled(currentIndex] = true;
  else menuEnabled[menuIndex] = false;
  if(menuEnabled[menuIndex]) enabledItems++;
System.out.println("Enabled menu items: \t"+enabledItems);</code><br/>
Вы гарантируете правильность работы этого куска кода? Может визуально отформатирован он правильно, но компилятор этого не увидит и интерпретирует этот кусок по-другому. Будет ошибка. Если не использовать контейнеры, то врядли можно будет написать что-то работающее. Это хорошо, что код отформатирован, и можно по нему восстановить структуру условий и цикла. А представьте, что код писался бы в каждой строке без отступов? Потребовалось бы гораздо больше времени, чтобы разбить это на контейнеры. Вот код, с использованием контейнеров.<br/>
<code java>for(int menuIndex = 0; menuIndex < MAX_MENU_ELEMENTS; menuIndex++) {
  if(menuIndex == currentIndex) {
    if(!menuEnabled[currentIndex]) {
      menuEnabled(currentIndex] = true;
    }
  } else {
      menuEnabled[menuIndex] = false;
  }
  if(menuEnabled[menuIndex]) enabledItems++;
}
System.out.println("Enabled menu items: \t"+enabledItems);</code>  <br/>
<br/>
Не обязательно повсюду использовать контейнеры. Чрезмерное их использование может не улучшить, а только ухудшить читаемость и восприятие кода. Одиночные сравнения можно и без контейнеров использовать, но только в том случае, когда операторы идущие после него не очень длинные.<br/>
<br/>
<br/>
[color 008800]Условия.[/color]<br/>
Условия являются одной из важных частей в программировании. Ни одна серьёзная программа не обходится без условий. Поэтому им нужно уделять достойное внимание. Заменяйте сложные условия на более простые, если это возможно. Также можете разбивать составные условия на отдельные логические переменные, и потом сравнивать их. В результате, длинные условия будут понятнее и меньше по объёму. Пример:<br/>
<code java>if( (readLines.length >= MAX_LINES) || (readStatus == STATUS_EOF && readStatus != STATUS_IO_ERROR) || (User.breakOperation) ) {
   showReadLines(readLines);
}</code><br/>
Можно заменить на это:<br/>
<code java>boolean readedMaxLines = (readLines.length >= MAX_LINES);
boolean endOfFile = (readStatus == STATUS_EOF && readStatus != STATUS_IO_ERROR);
if( readedMaxLines || endOfFile || User.breakOperation ) {
   showReadLines(readLines);
}</code><br/>
При таком подходе уменьшаются длинные условия, кроме того каждая часть условия становится яснее. Единственным минусом является создание новых переменных. В принципе это ваше право, использовать такой метод или нет. Как вариант, могу предложить и такой исход событий:<br/>
<code java>if(    (readLines.length >= MAX_LINES) //Прочитан лимит строк
   || (readStatus == STATUS_EOF && readStatus != STATUS_IO_ERROR) //Достигнут конец файла
   || (User.breakOperation) //Операция прервана пользователем
 ) {
   showReadLines(readLines);
}</code><br/>
Таким образом, каждое из составных условий будет задокументировано.<br/>
<br/>
<br/>
[color FF0000]Выводы.[/color]<br/>
Думаю, на этом можно и остановится. Придерживаясь хотя бы этих советов, ваш код станет более дружелюбным, и вам всегда захочется вернуться к нему, как к любимому рассказу. К тому же его будет не стыдно показать другим людям. Из личного опыта могу отметить, что хорошо оформленный и закомментированный исходник - гарантия на получение лишнего десятка баллов на экзамене, которые могут быть и решающими.<br/>
Попрактикуйтесь немного и выработайте свой стиль форматирования кода и объявления переменных. Затем покажите свой код нескольким друзьям, и если они поймут его быстро, то можете быть собою довольны - вы научились писать понятный код. Остальное - дело привычки. Успехов вам.<br/>
<br/>
<br/>
==4. Отладка и тестирование.==<br/>
<br/>
Как бы вы не писали своё приложение, в пьяном или трезвом виде, ошибки неизбежны. Они встречаются как у новичков, так и у гуру программирования. Поэтому их нужно исправлять. Когда этим исправлением занимается сам разработчик, это называется отладкой. Программист запускает отладчик, и просматривает все проблемные места в работе программы, попутно пытаясь их исправить. Тестирование - это страшный кошмар программиста. Он отдаёт своё приложение тестерам - людям, которые получают деньги за унижение разработчиков, людям, которые на дурняк используют его работы и при этом критикуют их по-полной. Эти люди используют его программные наработки несколько дней, затем приносят отчёт, мол, так и так, господин программист, ничего в вашей программе не работает должным образом. Программист, на основе их замечаний садится, и исправляет все найденные тестерами ошибки.<br/>
Вот поэтому многие любители-программисты пропускают этот этап, боясь худшего. Но на самом деле в тестировании нет ничего плохого. Наоборот, лучше заплатить хорошим тестерам, чтобы они протестировали работу программы, как следует, потом взять, всё это исправить и выпустить в свет, чем пропустить этап тестирования, и явить своё творение народу в голом виде и на следующий день получить кучу угроз в свой адрес. Мол, сгорел компьютер, лёг сервер и т.д. Вместо чека на сумму с единичкой и приличной последовательностью нулей, вы получите штраф на эту же сумму. А всё из-за того, что не провели тестирование.<br/>
<br/>
<br/>
Как можно тестировать свою программу?<br/>
Вариантов множество. Для начала можно просто запустить её и ввести заведомо правильные данные. Затем ввести какие-нибудь ложные данные, которые вообще не допустимы в ней. Если программа рухнет, обзывая вас нехорошими словами, значит тест пройден успешно. Да-да, именно успешно. Ведь целью теста является не проверка работоспособности программы, а её проверка на наличие ошибок. Если ошибка обнаружена, значит тест успешен. Если ошибок нет, значит это плохой тест, нужен лучше. Всегда старайтесь отталкиваться от этого правила. Действительно, если простенький тест прошел неуспешно, то это не значит, что ошибка не подкрадётся с другой стороны. Поэтому нужен более мощный тест.<br/>
Еще один вариант - функциональное тестирование, которое делится на два подвида: тестирование связей и тестирование функционала. В первом случае вы тестируете функцию на её взаимосвязь с другими. Не рушится ли эта связь при передаче недопустимых данных, или в любой другой внештатной ситуации. Во втором случае - тестируете внутренность функции. Правильно ли она делает расчеты, всё ли верно возвращает, не происходит ли там утечка памяти и так далее. Если вы сомневаетесь в том, правильно ли проводит та или иная функция необходимые расчеты, то возьмите калькулятор и сами попробуйте проверить это. Так вы будете уверены в правильности, вспомните алгебру и будете больше понимать код. <br/>
<br/>
[color FF0000]Вывод.[/color]<br/>
В общем, тестируйте всё что можете, пока не будете уверены в том, что ошибок больше нет. Поверьте, гораздо лучше получить список ошибок от группки тестеров, чем от тысячи пользователей.<br/>
<br/>
<br/>
==5. Развёртывание и сопровождение.==<br/>
<br/>
Развёртывание - как я и говорил, это то, как поведёт себя программа, при установке на аппарат пользователя. Описывать не буду, так как это всё дело решается на этапе тестирования.<br/>
<br/>
После того, как вы прошли самые сложные этапы разработки, самое время перейти к нудному - написанию документации. Если вы на этапе кодирования писали полноценные комментарии, то с этим проблем не будет - есть масса средств, способных превратить комментарии к исходному коду в документацию. Ярким примером тому является JavaDocs. Если же вы пили пиво и играли с сотрудниками в Quake, то, разумеется, комментариев в своём коде, кроме "Тут не пашет", "Исправить", "Писалось по пьяни, переписать на трезвую голову", вы не увидите. Ну что поделать, не останавливаться же в шаге от своей цели? Сумели пройти первые четыре этапа, сумеете и последний пройти.<br/>
Каких-либо советов давать не буду, кроме тех, которые давал в третьей статье - пишите комментарии.<br/>
<br/>
Вывод.<br/>
Удалите Quake.<br/>
<br/>
<br/>
==Послесловие.==<br/>
<br/>
Тот объём информации, что я дал в этих статьях, ничтожно мал. Но я и не ставил себе цель написать толстый учебник по разработке ПО. Напротив, я старался написать доступный, простой для понимания набор статей, чтобы большинство людей могли почерпнуть самые важные основы, и не допускали банальных ошибок. К сожалению, мне часто приходится видеть код наподобие этого:<br/>
<br/>
<code java>public class Can extends Canvas {
Can() {setFullScreenMode(true);}
String nc="",n1="";
int x=10,cls=0,xx;

public void paint(Graphics g) {
g.setFont(Font.get(0,1,8));
g.fillRect(10,10,121,20);
g.drawRect(10,30,120,20);
g.drawString(n1,x,34,20);
g.setColor(255,255,255);
g.drawString("input x",14,14,20);
g.fillRect(11,31,cls,18);
cls=0;
}

protected void keyPressed(int kc) {
nc=nc+n1;
switch(kc) {case -6: xx=Integer.parseInt(nc);
cls=119; nc=""; x=10; break; }// lsoft  "ok"
 switch(kc) {case -7:
cls=119; x=10; n1=""; xx=0; break; }// rsoft  "delete"
if(x<112) {
for(int i=48;i<58;i++) {
if(kc==i) {n1=""+(i-48); x+=7; break;
}}}
repaint();
}</code><br/>
<br/>
Вот, в качестве домашнего задания я и предлагаю вам превратить этот код в более понятный. Даже если ничего не получится, главное, чтобы вы просто попытались.<br/>
Надеюсь, я вам дал толчок к развитию, потому что всегда есть к чему стремится. Если хотите, можете прислать получившийся код мне, или запостить в комментарий.<br/>
<br/>
Напоследок, я предлагаю вам почитать книгу Стива Макконнелла "Совершенный код". Если вы в серьёз решили стать программистом, или просто хотите улучшить свои навыки, то прочитайте эту книгу. В ней нет упора на конкретный язык программирования, поэтому знание языков вам и не понадобится. Зато вы поймёте, как соблюдая простые правила, можно эффективно писать код, затрачивая меньше усилий. Книга также будет полезна не только новичкам, но и профессионалам.<br/>
<br/>
Вроде всё, с вами был Виктор aNNiMON Мельник. Удачи вам в разработках =)<br/>
<br/>
Первый Dень Лета 2011 год.